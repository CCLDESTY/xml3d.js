
/*************************************************************************/
/*                                                                       */
/*  xml3d_classes.js                                                     */
/*  Configures generic elements to provide XML3D IDLs					 */
/*                                                                       */
/*  Copyright (C) 2010                                                   */
/*  DFKI - German Research Center for Artificial Intelligence            */
/*                                                                       */
/*  This file is part of xml3d.js                                        */
/*                                                                       */
/*  xml3d.js is free software; you can redistribute it and/or modify     */
/*  under the terms of the GNU General Public License as                 */
/*  published by the Free Software Foundation; either version 2 of       */
/*  the License, or (at your option) any later version.                  */
/*                                                                       */
/*  xml3d.js is distributed in the hope that it will be useful, but      */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of           */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                 */
/*  See the GNU General Public License                                   */
/*  (http://www.fsf.org/licensing/licenses/gpl.html) for more details.   */
/*                                                                       */
/*************************************************************************/

 // ===> THIS CODE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY <===
 
//Check, if basics have already been defined
var org;
if (!org || !org.xml3d)
  throw new Error("xml3d.js has to be included first");

//Create global symbol org.xml3d.webgl
if (!org.xml3d.event)
	org.xml3d.event = {};
else if (typeof org.xml3d.event != "object")
	throw new Error("org.xml3d.event already exists and is not an object");

//Create global symbol org.xml3d.data
if (!org.xml3d.data)
	org.xml3d.data = {};
else if (typeof org.xml3d.data != "object")
	throw new Error("org.xml3d.data already exists and is not an object");


/* 
 * Workaround for DOMAttrModified issues in WebKit based browsers:
 * https://bugs.webkit.org/show_bug.cgi?id=8191
 */
if(navigator.userAgent.indexOf("WebKit") != -1)
{
	var attrModifiedWorks = false;
	var listener = function(){ attrModifiedWorks = true; };
	document.documentElement.addEventListener("DOMAttrModified", listener, false);
	document.documentElement.setAttribute("___TEST___", true);
	document.documentElement.removeAttribute("___TEST___", true);
	document.documentElement.removeEventListener("DOMAttrModified", listener, false);
	
	if (!attrModifiedWorks)
	{
		Element.prototype.__setAttribute = HTMLElement.prototype.setAttribute;

		Element.prototype.setAttribute = function(attrName, newVal)
		{
			var prevVal = this.getAttribute(attrName);
			this.__setAttribute(attrName, newVal);
			newVal = this.getAttribute(attrName);
			if (newVal != prevVal)
			{
				var evt = document.createEvent("MutationEvent");
				evt.initMutationEvent(
						"DOMAttrModified",
						true,
						false,
						this,
						prevVal || "",
						newVal || "",
						attrName,
						(prevVal == null) ? evt.ADDITION : evt.MODIFICATION
				);
				this.dispatchEvent(evt);
			}
		};
		
		Element.prototype.__removeAttribute = HTMLElement.prototype.removeAttribute;
		Element.prototype.removeAttribute = function(attrName)
		{
			var prevVal = this.getAttribute(attrName);
			this.__removeAttribute(attrName);
			var evt = document.createEvent("MutationEvent");
			evt.initMutationEvent(
					"DOMAttrModified",
					true,
					false,
					this,
					prevVal,
					"",
					attrName,
					evt.REMOVAL
			);
			this.dispatchEvent(evt);
		};
	}
}


org.xml3d.classInfo = {};
org.xml3d.methods = {};
org.xml3d.document = null;

org.xml3d.data.configure = function(xml3ds) {
 	if (!org.xml3d.document)
 		org.xml3d.document = new org.xml3d.XML3DDocument();

 	for(var x in xml3ds) {
 		org.xml3d.document.initXml3d(xml3ds[x]);
 	}
};

org.xml3d.defineClass = function(ctor, parent, methods) {
	if (parent) {
		function inheritance() {
		}
		inheritance.prototype = parent.prototype;
		ctor.prototype = new inheritance();
		ctor.prototype.constructor = ctor;
		ctor.superClass = parent;
	}
	if (methods) {
		for ( var m in methods) {
			ctor.prototype[m] = methods[m];
		}
	}
	return ctor;
};

org.xml3d.isa = function(object, classInfo) {
	var oClass = object._classInfo;
	while (oClass !== undefined)  {
		if (oClass == classInfo)
			return true;
		oClass = oClass.constructor.superClass;
	}
	return false;
};

// -----------------------------------------------------------------------------
// Class URI
// -----------------------------------------------------------------------------
org.xml3d.URI = function(str) {
	if (!str)
		str = "";
	// Based on the regex in RFC2396 Appendix B.
	var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
	var result = str.match(parser);
	this.scheme = result[1] || null;
	this.authority = result[2] || null;
	this.path = result[3] || null;
	this.query = result[4] || null;
	this.fragment = result[5] || null;
};

// Restore the URI to it's stringy glory.
org.xml3d.URI.prototype.toString = function() {
	var str = "";
	if (this.scheme) {
		str += this.scheme + ":";
	}
	if (this.authority) {
		str += "//" + this.authority;
	}
	if (this.path) {
		str += this.path;
	}
	if (this.query) {
		str += "?" + this.query;
	}
	if (this.fragment) {
		str += "#" + this.fragment;
	}
	return str;
};

// -----------------------------------------------------------------------------
// Class URIResolver
// -----------------------------------------------------------------------------
org.xml3d.URIResolver = function() {
};

org.xml3d.URIResolver.resolve = function(document, uriStr) {
	if (!document || !uriStr)
		return null;
	var uri = new org.xml3d.URI(uriStr);

	if (uri.scheme == 'urn')
	{
		org.xml3d.debug.logInfo("++ Found URN." + uriStr);
		return null;
	}

	if (!uri.path)
		return org.xml3d.URIResolver.resolveLocal(document, uri.fragment);


	org.xml3d.debug.logWarning("++ Can't resolve global hrefs yet: " + uriStr);
	// TODO Resolve intra-document references
	return null;
};

org.xml3d.URIResolver.resolveLocal = function(document, id) {
	if (document !== undefined && document) {
		var elem = document.getElementById(id);
		//org.xml3d.debug.logInfo("++ Found: " + elem);
		if (elem)
		{
			var node = document.getNode(elem);
			//org.xml3d.debug.logInfo("++ Found: " + node);
			return node;
		}
	}
	return null;
};

var getElementByIdWrapper = function(xmldoc, myID, namespace) {

};

// -----------------------------------------------------------------------------
// Class XML3DNodeFactory
// -----------------------------------------------------------------------------
org.xml3d.XML3DNodeFactory = function() {
};

org.xml3d.XML3DNodeFactory.isXML3DNode = function(node) {
	return (node.nodeType === Node.ELEMENT_NODE && (node.namespaceURI == org.xml3d.xml3dNS));
};

org.xml3d.XML3DNodeFactory.prototype.create = function(node, context) {
	var n, t;
	if (org.xml3d.XML3DNodeFactory.isXML3DNode(node)) {
		var classInfo = org.xml3d.classInfo[node.localName];
		if (classInfo === undefined) {
			org.xml3d.debug.logInfo("Unrecognised element " + node.localName);
		} else {
			//classInfo.configure(node, context);
			classInfo(node, context);
			node._configured = true;
			node._classInfo = classInfo;
			//n = new elementType(ctx);
			//node._xml3dNode = n;
			Array.forEach(Array.map(node.childNodes, function(n) {
				return this.create(n, context);
			}, this), function(c) {

			});
			return n;
		}
	}
};

org.xml3d.XML3DNodeFactory.createXML3DVec3FromString = function(value) {
	var result = new XML3DVec3();
	result.setVec3Value(value);
	return result;
};

org.xml3d.XML3DNodeFactory.createXML3DRotationFromString = function(value) {
	var result = new XML3DRotation();
	result.setAxisAngleValue(value);
	return result;
};

org.xml3d.XML3DNodeFactory.createBooleanFromString = function(value) 
{
	return new Boolean(value);
};

org.xml3d.XML3DNodeFactory.createStringFromString = function(value) 
{
	return new String(value);
};

org.xml3d.XML3DNodeFactory.createIntFromString = function(value) 
{
	return parseInt(value);
};

org.xml3d.XML3DNodeFactory.createFloatFromString = function(value) 
{
	return parseFloat(value);
};

org.xml3d.XML3DNodeFactory.createAnyURIFromString = function(value) 
{
	//TODO: not implemented
	return value;
};

org.xml3d.XML3DNodeFactory.createEnumFromString = function(value) 
{
	//TODO: not implemented
	return value;
};
// -----------------------------------------------------------------------------
// Class XML3Document
// -----------------------------------------------------------------------------
org.xml3d.XML3DDocument = function(parentDocument) {
	this.parentDocument = parentDocument;
	this.factory = new org.xml3d.XML3DNodeFactory();
	this.onload = function() {
		alert("on load");
	};
	this.onerror = function() {
		alert("on error");
	};
};

org.xml3d.XML3DDocument.prototype.initXml3d = function(xml3dElement) {

	if (xml3dElement._xml3dNode !== undefined)
		return;

	xml3dNode = this.getNode(xml3dElement);
	xml3dElement.addEventListener('DOMNodeRemoved', this.onRemove, true);
	xml3dElement.addEventListener('DOMNodeInserted', this.onAdd, true);
	xml3dElement.addEventListener('DOMAttrModified', this.onSet, true);
	xml3dElement.addEventListener('DOMCharacterDataModified', this.onTextSet, true);

};

org.xml3d.XML3DDocument.prototype.onTextSet = function(e){
	if (e.target === undefined)
	{
		org.xml3d.debug.logInfo("Unhandled event on: " + e.target.localName);
		return;
	}
	try
    {
        var bindNode = e.target.parentNode;
        var oldValue = e.target.parentNode.value;

        e.target.parentNode.setValue(e);

        if (bindNode.notificationRequired() && oldValue != e.target.parentNode.value)
            bindNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "text", oldValue, e.target.parentNode.value));
    }
    catch (e)
    {
        org.xml3d.debug.logError("Exception in textSet:");
        org.xml3d.debug.logException(e);
    } 
};

org.xml3d.XML3DDocument.prototype.onAdd = function(e) {
	try {
		org.xml3d.document.getNode(e.target);
	} catch (e) {
		org.xml3d.debug.logError("Exception in configuring node:");
		org.xml3d.debug.logException(e);
	}
};

org.xml3d.XML3DDocument.prototype.onSet = function(e) {
	if (e.target === undefined)
	{
		org.xml3d.debug.logInfo("Unhandled event on: " + e.target.localName);
		return;
	}

	try 
	{
		var result;
		
		if(e.attrChange == MutationEvent.REMOVAL)
		{
			result = e.target.resetAttribute(e.attrName);
		}
		else if(e.attrChange == MutationEvent.MODIFICATION)
		{
			result = e.target.setField(e);
		}
		else
		{
			org.xml3d.debug.logWarn("Unexpected MutationEvent.ADDITION event for attribute " + 
			                        e.attrName + 
			                        " in node " + 
			                        e.target.localName + " ==> not handled");
			return;
		}
	
		
		if (result == org.xml3d.event.HANDLED &&
			e.target.notificationRequired()   && 
			e.prevValue != e.newValue)
		{
			// The removal of an attribute is also handled as MutationEvent.MODIFICATION since
			// this event is handled by resetting the internal attribute value.
			e.target.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, e.attrName, e.prevValue, e.newValue));
		}
	 }
	 catch (e) 
	 {
		org.xml3d.debug.logError("Exception in setField:");
		org.xml3d.debug.logException(e);
	}
};

org.xml3d.XML3DDocument.prototype.onRemove = function(e) 
{
	org.xml3d.debug.logInfo("Remove: "+e);
	
	if (e.target === undefined)
	{
		org.xml3d.debug.logInfo("Unhandled event on: " + e.target.localName);
		return;
	}
	try
    {
        var bindNode = e.target;

        if (bindNode.notificationRequired())
        {
            bindNode.notify(new org.xml3d.Notification(this, MutationEvent.REMOVAL, "node", e.prevValue, e.newValue));
        }
        
        for(var i = 0; i < bindNode.adapters.length; i++)
        {
        	var adapter = bindNode.adapters[i];
        	if(adapter.dispose)
        	{
        		adapter.dispose();
        	}
        }
    }
    catch (e)
    {
        org.xml3d.debug.logError("Exception in onRemove:");
        org.xml3d.debug.logException(e);
    } 
};

org.xml3d.XML3DDocument.prototype.onunload = function(xml3dElement) {
};

org.xml3d.XML3DDocument.prototype.getNode = function(element) {
	if (element._configured !== undefined)
		return element;

	var ctx = {
			assert : org.xml3d.debug.assert,
			log : org.xml3d.debug.logInfo,
			factory : this.factory,
			doc : this
		};
	return this.factory.create(element, ctx);
};

org.xml3d.XML3DDocument.prototype.resolve = function(uriStr) {
		return org.xml3d.URIResolver.resolve(this, uriStr);
};

org.xml3d.XML3DDocument.prototype.nativeGetElementById = document.getElementById;

org.xml3d.XML3DDocument.prototype.getElementById = function(id) {
	return document.getElementById(id);
};

//-----------------------------------------------------------------------------
//Class Notification
//-----------------------------------------------------------------------------
org.xml3d.Notification = function(notifier, eventType, attribute, oldValue, newValue) {
	this.notifier = notifier;
	this.eventType = eventType;
	this.attribute = attribute;
	this.oldValue = oldValue;
	this.newValue = newValue;
};

//-----------------------------------------------------------------------------
// Adapter and Adapter factory
//-----------------------------------------------------------------------------

org.xml3d.data.Adapter = function(factory, node) {
	this.factory = factory; // optional
	this.node = node; // optional
	this.init = function() {
	  // Init is called by the factory after adding the adapter to the node
	};

};
org.xml3d.data.Adapter.prototype.notifyChanged = function(e) {
	 // Notification from the data structure. e is of type org.xml3d.Notification.
};
org.xml3d.data.Adapter.prototype.isAdapterFor = function(aType) {
	 return false; // Needs to be overwritten
};


org.xml3d.data.AdapterFactory = function() {
	this.getAdapter = function(node, atype) {
		if (!node || node._configured === undefined)
			return null;
		for (i = 0; i < node.adapters.length; i++) {
			if (node.adapters[i].isAdapterFor(atype)) {
				return node.adapters[i];
			}
		}
		// No adapter found, try to create one
		var adapter = this.createAdapter(node);
		if (adapter) {
			node.addAdapter(adapter);
			adapter.init();
		}
		return adapter;
	};
};
org.xml3d.data.AdapterFactory.prototype.createAdapter = function(node) {
		return null;
};

//-----------------------------------------------------------------------------
// Init helper
//-----------------------------------------------------------------------------
org.xml3d.initFloat = function(value, defaultValue) {
	return value ? +value : defaultValue;
};

org.xml3d.initString = function(value, defaultValue) {
	return value ? value : defaultValue;
};

org.xml3d.initInt = function(value, defaultValue) {
	return value ? parseInt(value) : defaultValue;
};

org.xml3d.initBoolean = function(value, defaultValue) {
	return value ? value == "true" : defaultValue;
};

org.xml3d.initXML3DVec3 = function(value, x, y, z) {
	if (value) {
		var result = new XML3DVec3();
		result.setVec3Value(value);
		return result;
	}
	else return new XML3DVec3(x, y, z);
};

org.xml3d.initXML3DRotation = function(value, x, y, z, angle) {
	var result = new XML3DRotation();
	if (value) {
		result.setAxisAngleValue(value);
	} else {
		result.setAxisAngle(new XML3DVec3(x, y, z), angle);
	}
	return result;
};

org.xml3d.initEnum = function(value, defaultValue, choice) {
	return (value && choice[value] !== undefined) ? choice[value]
			: defaultValue;
};

org.xml3d.initIntArray = function(value, defaultValue) {
	var exp = /([+\-0-9]+)/g;
	return value ? new Int32Array(value.match(exp)) : new Int32Array(defaultValue);
};

org.xml3d.initUInt16Array = function(value, defaultValue) {
	var exp = /([+\-0-9]+)/g;
	return value ? new Uint16Array(value.match(exp)) : new Uint16Array(defaultValue);
};

org.xml3d.initFloatArray = function(value, defaultValue) {
	var exp = /([+\-0-9eE\.]+)/g;
	return value ? new Float32Array(value.match(exp)) :  new Float32Array(defaultValue);
};

org.xml3d.initFloat3Array = function(value, defaultValue) {
	return org.xml3d.initFloatArray(value, defaultValue);
};

org.xml3d.initFloat2Array = function(value, defaultValue) {
	return org.xml3d.initFloatArray(value, defaultValue);
};

org.xml3d.initFloat4Array = function(value, defaultValue) {
	return org.xml3d.initFloatArray(value, defaultValue);
};

org.xml3d.initFloat4x4Array = function(value, defaultValue) {
	return org.xml3d.initFloatArray(value, defaultValue);
};

org.xml3d.initBoolArray = function(value, defaultValue) {
	var converted = value.replace(/(true)/i, "1").replace(/(false)/i, "0");
	return new Uint8Array(converted.match(/\d/i));
};

org.xml3d.initAnyURI = function(node, defaultValue) {
	return org.xml3d.initString(node, defaultValue);
};

// MeshTypes
org.xml3d.MeshTypes = {};
org.xml3d.MeshTypes["triangles"] = 0;
org.xml3d.MeshTypes["triangleStrips"] = 1;
// TextureTypes
org.xml3d.TextureTypes = {};
org.xml3d.TextureTypes["2D"] = 0;
org.xml3d.TextureTypes["1D"] = 1;
org.xml3d.TextureTypes["3D"] = 2;
// FilterTypes
org.xml3d.FilterTypes = {};
org.xml3d.FilterTypes["none"] = 0;
org.xml3d.FilterTypes["nearest"] = 1;
org.xml3d.FilterTypes["linear"] = 2;
// WrapTypes
org.xml3d.WrapTypes = {};
org.xml3d.WrapTypes["clamp"] = 0;
org.xml3d.WrapTypes["repeat"] = 1;
org.xml3d.WrapTypes["border"] = 2;

// Initialize methods
org.xml3d.event.UNHANDLED = 1;
org.xml3d.event.HANDLED = 2;


/**
 * Register class for element <Xml3dNode>
 */
org.xml3d.classInfo.Xml3dNode = function(node, c) 
{
	node.xml3ddocument = c.doc;
	node.adapters      = [];

	node.addAdapter = function(adapter) 
	{
		this.adapters.push(adapter);
	};
	
	node.getTextContent = function() 
	{
		var str = "";
		var k   = this.firstChild;
		
		while(k) 
		{
			if (k.nodeType == 3)
			{
				str += k.textContent;
			}
			
			k = k.nextSibling;
		}
		return str;
	};
	
	node.notificationRequired = function () 
	{
		return this.adapters.length != 0;
	};

	node.notify = function (notification) 
	{
		for(var i= 0; i < this.adapters.length; i++)
		{
		  this.adapters[i].notifyChanged(notification);
		}
	};
	
	node.update = function() 
	{
		if (this.adapters[0])
			this.adapters[0].factory.ctx.redraw();
 	};
 	
	node.setField = function(event) 
	{
		return org.xml3d.event.UNHANDLED;
	};
	
	node.evalMethod = function(evtMethod) 
	{
		if (evtMethod)
			eval(evtMethod);
	};
};

// [@abstract='false']
/**
 * Object org.xml3d.classInfo.XML3DBaseType()
 * 
 * @augments org.xml3d.classInfo.Xml3dNode
 * @constructor
 * @see org.xml3d.classInfo.Xml3dNode
 */
org.xml3d.classInfo.XML3DBaseType = function(node, context) 
{
	org.xml3d.classInfo.Xml3dNode(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.xml3d()
 * 
 * @augments org.xml3d.classInfo.XML3DBaseType
 * @constructor
 * @see org.xml3d.classInfo.XML3DBaseType
 */
org.xml3d.classInfo.xml3d = function(node, context) 
{
	org.xml3d.classInfo.XML3DBaseType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("height", function (value) 
	{
		var oldValue = this._height;
		if (typeof value == 'string')
		{
		   this._height = org.xml3d.initInt(node.getAttribute("height"), 600);
		   
		   if(this._height.setOwnerNode)
		   {
		   	  this._height.setOwnerNode("height", this);
		   }
		}
		else
		{
		   this._height = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._height)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "height", oldValue, this._height));
		}
	});
  
	node.__defineGetter__("height", function (value) 
	{
        return this._height;
    });
	node.__defineSetter__("width", function (value) 
	{
		var oldValue = this._width;
		if (typeof value == 'string')
		{
		   this._width = org.xml3d.initInt(node.getAttribute("width"), 800);
		   
		   if(this._width.setOwnerNode)
		   {
		   	  this._width.setOwnerNode("width", this);
		   }
		}
		else
		{
		   this._width = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._width)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "width", oldValue, this._width));
		}
	});
  
	node.__defineGetter__("width", function (value) 
	{
        return this._width;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "height")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.height = 600;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "width")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.width = 800;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._height = org.xml3d.initInt(node.getAttribute("height"), 600);
	if(node._height.setOwnerNode)
	{
		node._height.setOwnerNode("height", this);
	}
	node._width = org.xml3d.initInt(node.getAttribute("width"), 800);
	if(node._width.setOwnerNode)
	{
		node._width.setOwnerNode("width", this);
	}

	//node.definitionArea = [];
	//node.graph = [];
	node.activeView = null;



	node.getActiveView = function() 
	{
		if (!this.activeView && this.hasAttribute("activeView"))
		{
		  this.activeView = this.xml3ddocument.resolve(this.getAttribute("activeView"));
		}
		return this.activeView;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "height") 
		{
			this.height = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "width") 
		{
			this.width = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.createXML3DVec3 = org.xml3d.methods.xml3dCreateXML3DVec3;
		node.createXML3DRotation = org.xml3d.methods.xml3dCreateXML3DRotation;
		node.createXML3DMatrix = org.xml3d.methods.xml3dCreateXML3DMatrix;
		node.createXML3DRay = org.xml3d.methods.xml3dCreateXML3DRay;
		node.getElementByPoint = org.xml3d.methods.xml3dGetElementByPoint;
	
};
/**
 * Object org.xml3d.classInfo.XML3DReferenceableType()
 * 
 * @augments org.xml3d.classInfo.XML3DBaseType
 * @constructor
 * @see org.xml3d.classInfo.XML3DBaseType
 */
org.xml3d.classInfo.XML3DReferenceableType = function(node, context) 
{
	org.xml3d.classInfo.XML3DBaseType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DDataContainerType()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.XML3DDataContainerType = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("map", function (value) 
	{
		var oldValue = this._map;
		if (typeof value == 'string')
		{
		   this._map = org.xml3d.initString(node.getAttribute("map"), "");
		   
		   if(this._map.setOwnerNode)
		   {
		   	  this._map.setOwnerNode("map", this);
		   }
		}
		else
		{
		   this._map = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._map)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "map", oldValue, this._map));
		}
	});
  
	node.__defineGetter__("map", function (value) 
	{
        return this._map;
    });
	node.__defineSetter__("expose", function (value) 
	{
		var oldValue = this._expose;
		if (typeof value == 'string')
		{
		   this._expose = org.xml3d.initString(node.getAttribute("expose"), "");
		   
		   if(this._expose.setOwnerNode)
		   {
		   	  this._expose.setOwnerNode("expose", this);
		   }
		}
		else
		{
		   this._expose = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._expose)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "expose", oldValue, this._expose));
		}
	});
  
	node.__defineGetter__("expose", function (value) 
	{
        return this._expose;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "map")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.map = "";
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "expose")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.expose = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._map = org.xml3d.initString(node.getAttribute("map"), "");
	if(node._map.setOwnerNode)
	{
		node._map.setOwnerNode("map", this);
	}
	node._expose = org.xml3d.initString(node.getAttribute("expose"), "");
	if(node._expose.setOwnerNode)
	{
		node._expose.setOwnerNode("expose", this);
	}

	//node.sources = [];




	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "map") 
		{
			this.map = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "expose") 
		{
			this.expose = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DNestedDataContainerType()
 * 
 * @augments org.xml3d.classInfo.XML3DDataContainerType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataContainerType
 */
org.xml3d.classInfo.XML3DNestedDataContainerType = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataContainerType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};


	//node.childContainers = [];
	node.src = null;



	node.getSrc = function() 
	{
		if (!this.src && this.hasAttribute("src"))
		{
		  this.src = this.xml3ddocument.resolve(this.getAttribute("src"));
		}
		return this.src;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "map") 
		{
			this.map = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "expose") 
		{
			this.expose = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.data()
 * 
 * @augments org.xml3d.classInfo.XML3DNestedDataContainerType
 * @constructor
 * @see org.xml3d.classInfo.XML3DNestedDataContainerType
 */
org.xml3d.classInfo.data = function(node, context) 
{
	org.xml3d.classInfo.XML3DNestedDataContainerType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};


	node.script = null;



	node.getScript = function() 
	{
		if (!this.script && this.hasAttribute("script"))
		{
		  this.script = this.xml3ddocument.resolve(this.getAttribute("script"));
		}
		return this.script;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "map") 
		{
			this.map = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "expose") 
		{
			this.expose = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.defs()
 * 
 * @augments org.xml3d.classInfo.XML3DBaseType
 * @constructor
 * @see org.xml3d.classInfo.XML3DBaseType
 */
org.xml3d.classInfo.defs = function(node, context) 
{
	org.xml3d.classInfo.XML3DBaseType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};


	//node.children = [];




	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DGraphType()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.XML3DGraphType = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("visible", function (value) 
	{
		var oldValue = this._visible;
		if (typeof value == 'string')
		{
		   this._visible = org.xml3d.initBoolean(node.getAttribute("visible"), true);
		   
		   if(this._visible.setOwnerNode)
		   {
		   	  this._visible.setOwnerNode("visible", this);
		   }
		}
		else
		{
		   this._visible = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._visible)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "visible", oldValue, this._visible));
		}
	});
  
	node.__defineGetter__("visible", function (value) 
	{
        return this._visible;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "visible")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.visible = true;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._visible = org.xml3d.initBoolean(node.getAttribute("visible"), true);
	if(node._visible.setOwnerNode)
	{
		node._visible.setOwnerNode("visible", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
	
};
/**
 * Object org.xml3d.classInfo.group()
 * 
 * @augments org.xml3d.classInfo.XML3DGraphType
 * @constructor
 * @see org.xml3d.classInfo.XML3DGraphType
 */
org.xml3d.classInfo.group = function(node, context) 
{
	org.xml3d.classInfo.XML3DGraphType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};


	node.transform = null;
	node.shader = null;
	//node.children = [];
	//node.defs = [];



	node.getTransform = function() 
	{
		if (!this.transform && this.hasAttribute("transform"))
		{
		  this.transform = this.xml3ddocument.resolve(this.getAttribute("transform"));
		}
		return this.transform;
	};
	node.getShader = function() 
	{
		if (!this.shader && this.hasAttribute("shader"))
		{
		  this.shader = this.xml3ddocument.resolve(this.getAttribute("shader"));
		}
		return this.shader;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
		node.getLocalMatrix = org.xml3d.methods.groupGetLocalMatrix;
	
};
/**
 * Object org.xml3d.classInfo.XML3DGeometryType()
 * 
 * @augments org.xml3d.classInfo.XML3DGraphType
 * @constructor
 * @see org.xml3d.classInfo.XML3DGraphType
 */
org.xml3d.classInfo.XML3DGeometryType = function(node, context) 
{
	org.xml3d.classInfo.XML3DGraphType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
	
};
/**
 * Object org.xml3d.classInfo.mesh()
 * 
 * @augments org.xml3d.classInfo.XML3DGeometryType
 * @constructor
 * @see org.xml3d.classInfo.XML3DGeometryType
 */
org.xml3d.classInfo.mesh = function(node, context) 
{
	org.xml3d.classInfo.XML3DGeometryType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("type", function (value) 
	{
		var oldValue = this._type;
		if (typeof value == 'string')
		{
		   this._type = org.xml3d.initEnum(node.getAttribute("type"), 0, org.xml3d.MeshTypes);
		   
		   if(this._type.setOwnerNode)
		   {
		   	  this._type.setOwnerNode("type", this);
		   }
		}
		else
		{
		   this._type = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._type)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "type", oldValue, this._type));
		}
	});
  
	node.__defineGetter__("type", function (value) 
	{
        return this._type;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "type")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.type = 0;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._type = org.xml3d.initEnum(node.getAttribute("type"), 0, org.xml3d.MeshTypes);
	if(node._type.setOwnerNode)
	{
		node._type.setOwnerNode("type", this);
	}

	//node.sources = [];
	//node.childContainers = [];
	node.src = null;



	node.getSrc = function() 
	{
		if (!this.src && this.hasAttribute("src"))
		{
		  this.src = this.xml3ddocument.resolve(this.getAttribute("src"));
		}
		return this.src;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "type") 
		{
			this.type = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
	
};
/**
 * Object org.xml3d.classInfo.XML3DTransformProviderType()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.XML3DTransformProviderType = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.transform()
 * 
 * @augments org.xml3d.classInfo.XML3DTransformProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DTransformProviderType
 */
org.xml3d.classInfo.transform = function(node, context) 
{
	org.xml3d.classInfo.XML3DTransformProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("translation", function (value) 
	{
		var oldValue = this._translation;
		if (typeof value == 'string')
		{
		   this._translation = org.xml3d.initXML3DVec3(node.getAttribute("translation"), 0, 0, 0);
		   
		   if(this._translation.setOwnerNode)
		   {
		   	  this._translation.setOwnerNode("translation", this);
		   }
		}
		else
		{
		   this._translation = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._translation)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "translation", oldValue, this._translation));
		}
	});
  
	node.__defineGetter__("translation", function (value) 
	{
        return this._translation;
    });
	node.__defineSetter__("scale", function (value) 
	{
		var oldValue = this._scale;
		if (typeof value == 'string')
		{
		   this._scale = org.xml3d.initXML3DVec3(node.getAttribute("scale"), 1, 1, 1);
		   
		   if(this._scale.setOwnerNode)
		   {
		   	  this._scale.setOwnerNode("scale", this);
		   }
		}
		else
		{
		   this._scale = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._scale)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "scale", oldValue, this._scale));
		}
	});
  
	node.__defineGetter__("scale", function (value) 
	{
        return this._scale;
    });
	node.__defineSetter__("rotation", function (value) 
	{
		var oldValue = this._rotation;
		if (typeof value == 'string')
		{
		   this._rotation = org.xml3d.initXML3DRotation(node.getAttribute("rotation"), 0, 0, 1, 0);
		   
		   if(this._rotation.setOwnerNode)
		   {
		   	  this._rotation.setOwnerNode("rotation", this);
		   }
		}
		else
		{
		   this._rotation = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._rotation)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "rotation", oldValue, this._rotation));
		}
	});
  
	node.__defineGetter__("rotation", function (value) 
	{
        return this._rotation;
    });
	node.__defineSetter__("center", function (value) 
	{
		var oldValue = this._center;
		if (typeof value == 'string')
		{
		   this._center = org.xml3d.initXML3DVec3(node.getAttribute("center"), 0, 0, 0);
		   
		   if(this._center.setOwnerNode)
		   {
		   	  this._center.setOwnerNode("center", this);
		   }
		}
		else
		{
		   this._center = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._center)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "center", oldValue, this._center));
		}
	});
  
	node.__defineGetter__("center", function (value) 
	{
        return this._center;
    });
	node.__defineSetter__("scaleOrientation", function (value) 
	{
		var oldValue = this._scaleOrientation;
		if (typeof value == 'string')
		{
		   this._scaleOrientation = org.xml3d.initXML3DRotation(node.getAttribute("scaleOrientation"), 0, 0, 1, 0);
		   
		   if(this._scaleOrientation.setOwnerNode)
		   {
		   	  this._scaleOrientation.setOwnerNode("scaleOrientation", this);
		   }
		}
		else
		{
		   this._scaleOrientation = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._scaleOrientation)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "scaleOrientation", oldValue, this._scaleOrientation));
		}
	});
  
	node.__defineGetter__("scaleOrientation", function (value) 
	{
        return this._scaleOrientation;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "translation")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.translation = 0, 0, 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "scale")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.scale = 1, 1, 1;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "rotation")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.rotation = 0, 0, 1, 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "center")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.center = 0, 0, 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "scaleOrientation")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.scaleOrientation = 0, 0, 1, 0;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._translation = org.xml3d.initXML3DVec3(node.getAttribute("translation"), 0, 0, 0);
	if(node._translation.setOwnerNode)
	{
		node._translation.setOwnerNode("translation", this);
	}
	node._scale = org.xml3d.initXML3DVec3(node.getAttribute("scale"), 1, 1, 1);
	if(node._scale.setOwnerNode)
	{
		node._scale.setOwnerNode("scale", this);
	}
	node._rotation = org.xml3d.initXML3DRotation(node.getAttribute("rotation"), 0, 0, 1, 0);
	if(node._rotation.setOwnerNode)
	{
		node._rotation.setOwnerNode("rotation", this);
	}
	node._center = org.xml3d.initXML3DVec3(node.getAttribute("center"), 0, 0, 0);
	if(node._center.setOwnerNode)
	{
		node._center.setOwnerNode("center", this);
	}
	node._scaleOrientation = org.xml3d.initXML3DRotation(node.getAttribute("scaleOrientation"), 0, 0, 1, 0);
	if(node._scaleOrientation.setOwnerNode)
	{
		node._scaleOrientation.setOwnerNode("scaleOrientation", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "translation") 
		{
			this.translation = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "scale") 
		{
			this.scale = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "rotation") 
		{
			this.rotation = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "center") 
		{
			this.center = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "scaleOrientation") 
		{
			this.scaleOrientation = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DShaderProviderType()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.XML3DShaderProviderType = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};


	node.script = null;
	//node.sources = [];
	//node.childContainers = [];
	node.src = null;



	node.getScript = function() 
	{
		if (!this.script && this.hasAttribute("script"))
		{
		  this.script = this.xml3ddocument.resolve(this.getAttribute("script"));
		}
		return this.script;
	};
	node.getSrc = function() 
	{
		if (!this.src && this.hasAttribute("src"))
		{
		  this.src = this.xml3ddocument.resolve(this.getAttribute("src"));
		}
		return this.src;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DSurfaceShaderProviderType()
 * 
 * @augments org.xml3d.classInfo.XML3DShaderProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DShaderProviderType
 */
org.xml3d.classInfo.XML3DSurfaceShaderProviderType = function(node, context) 
{
	org.xml3d.classInfo.XML3DShaderProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.shader()
 * 
 * @augments org.xml3d.classInfo.XML3DSurfaceShaderProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DSurfaceShaderProviderType
 */
org.xml3d.classInfo.shader = function(node, context) 
{
	org.xml3d.classInfo.XML3DSurfaceShaderProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.light()
 * 
 * @augments org.xml3d.classInfo.XML3DGraphType
 * @constructor
 * @see org.xml3d.classInfo.XML3DGraphType
 */
org.xml3d.classInfo.light = function(node, context) 
{
	org.xml3d.classInfo.XML3DGraphType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("global", function (value) 
	{
		var oldValue = this._global;
		if (typeof value == 'string')
		{
		   this._global = org.xml3d.initBoolean(node.getAttribute("global"), false);
		   
		   if(this._global.setOwnerNode)
		   {
		   	  this._global.setOwnerNode("global", this);
		   }
		}
		else
		{
		   this._global = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._global)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "global", oldValue, this._global));
		}
	});
  
	node.__defineGetter__("global", function (value) 
	{
        return this._global;
    });
	node.__defineSetter__("intensity", function (value) 
	{
		var oldValue = this._intensity;
		if (typeof value == 'string')
		{
		   this._intensity = org.xml3d.initFloat(node.getAttribute("intensity"), 1);
		   
		   if(this._intensity.setOwnerNode)
		   {
		   	  this._intensity.setOwnerNode("intensity", this);
		   }
		}
		else
		{
		   this._intensity = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._intensity)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "intensity", oldValue, this._intensity));
		}
	});
  
	node.__defineGetter__("intensity", function (value) 
	{
        return this._intensity;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "global")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.global = false;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "intensity")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.intensity = 1;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._global = org.xml3d.initBoolean(node.getAttribute("global"), false);
	if(node._global.setOwnerNode)
	{
		node._global.setOwnerNode("global", this);
	}
	node._intensity = org.xml3d.initFloat(node.getAttribute("intensity"), 1);
	if(node._intensity.setOwnerNode)
	{
		node._intensity.setOwnerNode("intensity", this);
	}

	node.shader = null;



	node.getShader = function() 
	{
		if (!this.shader && this.hasAttribute("shader"))
		{
		  this.shader = this.xml3ddocument.resolve(this.getAttribute("shader"));
		}
		return this.shader;
	};

	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "global") 
		{
			this.global = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "intensity") 
		{
			this.intensity = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
	
};
/**
 * Object org.xml3d.classInfo.XML3DLightShaderProviderType()
 * 
 * @augments org.xml3d.classInfo.XML3DShaderProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DShaderProviderType
 */
org.xml3d.classInfo.XML3DLightShaderProviderType = function(node, context) 
{
	org.xml3d.classInfo.XML3DShaderProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.lightshader()
 * 
 * @augments org.xml3d.classInfo.XML3DLightShaderProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DLightShaderProviderType
 */
org.xml3d.classInfo.lightshader = function(node, context) 
{
	org.xml3d.classInfo.XML3DLightShaderProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.script()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.script = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initString(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};
	node.__defineSetter__("src", function (value) 
	{
		var oldValue = this._src;
		if (typeof value == 'string')
		{
		   this._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
		   
		   if(this._src.setOwnerNode)
		   {
		   	  this._src.setOwnerNode("src", this);
		   }
		}
		else
		{
		   this._src = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._src)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "src", oldValue, this._src));
		}
	});
  
	node.__defineGetter__("src", function (value) 
	{
        return this._src;
    });
	node.__defineSetter__("type", function (value) 
	{
		var oldValue = this._type;
		if (typeof value == 'string')
		{
		   this._type = org.xml3d.initString(node.getAttribute("type"), "");
		   
		   if(this._type.setOwnerNode)
		   {
		   	  this._type.setOwnerNode("type", this);
		   }
		}
		else
		{
		   this._type = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._type)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "type", oldValue, this._type));
		}
	});
  
	node.__defineGetter__("type", function (value) 
	{
        return this._type;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "src")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.src = "";
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "type")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.type = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initString(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}
	node._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
	if(node._src.setOwnerNode)
	{
		node._src.setOwnerNode("src", this);
	}
	node._type = org.xml3d.initString(node.getAttribute("type"), "");
	if(node._type.setOwnerNode)
	{
		node._type.setOwnerNode("type", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		if (attrName == "src") 
		{
			this.src = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "type") 
		{
			this.type = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DDataSourceType()
 * 
 * @augments org.xml3d.classInfo.XML3DBaseType
 * @constructor
 * @see org.xml3d.classInfo.XML3DBaseType
 */
org.xml3d.classInfo.XML3DDataSourceType = function(node, context) 
{
	org.xml3d.classInfo.XML3DBaseType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("name", function (value) 
	{
		var oldValue = this._name;
		if (typeof value == 'string')
		{
		   this._name = org.xml3d.initString(node.getAttribute("name"), "");
		   
		   if(this._name.setOwnerNode)
		   {
		   	  this._name.setOwnerNode("name", this);
		   }
		}
		else
		{
		   this._name = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._name)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "name", oldValue, this._name));
		}
	});
  
	node.__defineGetter__("name", function (value) 
	{
        return this._name;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "name")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.name = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._name = org.xml3d.initString(node.getAttribute("name"), "");
	if(node._name.setOwnerNode)
	{
		node._name.setOwnerNode("name", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.float()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.float = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initFloatArray(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initFloatArray(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.float2()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.float2 = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initFloat2Array(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initFloat2Array(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.float3()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.float3 = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initFloat3Array(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initFloat3Array(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.float4()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.float4 = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initFloat4Array(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initFloat4Array(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.float4x4()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.float4x4 = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initFloat4x4Array(e.newValue, []); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initFloat4x4Array(node.getTextContent(), []);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.int()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.int = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initIntArray(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initIntArray(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.bool()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.bool = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	// TODO: Setter for mixed value
	node.setValue = function(e) 
	{
		var oldValue = this.value;
		this.value = org.xml3d.initBoolArray(e.newValue, null); 
		
		if (this.parentNode.notificationRequired() && oldValue != this.value)
		{
	    	this.parentNode.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "value", oldValue, this.value));
		}
	};

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};

	node.value = org.xml3d.initBoolArray(node.getTextContent(), null);

	if(node.value.setOwnerNode)
	{
		node.value.setOwnerNode("value", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
			// TODO: Mixed value change
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.texture()
 * 
 * @augments org.xml3d.classInfo.XML3DDataSourceType
 * @constructor
 * @see org.xml3d.classInfo.XML3DDataSourceType
 */
org.xml3d.classInfo.texture = function(node, context) 
{
	org.xml3d.classInfo.XML3DDataSourceType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("type", function (value) 
	{
		var oldValue = this._type;
		if (typeof value == 'string')
		{
		   this._type = org.xml3d.initEnum(node.getAttribute("type"), 0, org.xml3d.TextureTypes);
		   
		   if(this._type.setOwnerNode)
		   {
		   	  this._type.setOwnerNode("type", this);
		   }
		}
		else
		{
		   this._type = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._type)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "type", oldValue, this._type));
		}
	});
  
	node.__defineGetter__("type", function (value) 
	{
        return this._type;
    });
	node.__defineSetter__("filterMin", function (value) 
	{
		var oldValue = this._filterMin;
		if (typeof value == 'string')
		{
		   this._filterMin = org.xml3d.initEnum(node.getAttribute("filterMin"), 2, org.xml3d.FilterTypes);
		   
		   if(this._filterMin.setOwnerNode)
		   {
		   	  this._filterMin.setOwnerNode("filterMin", this);
		   }
		}
		else
		{
		   this._filterMin = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._filterMin)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "filterMin", oldValue, this._filterMin));
		}
	});
  
	node.__defineGetter__("filterMin", function (value) 
	{
        return this._filterMin;
    });
	node.__defineSetter__("filterMag", function (value) 
	{
		var oldValue = this._filterMag;
		if (typeof value == 'string')
		{
		   this._filterMag = org.xml3d.initEnum(node.getAttribute("filterMag"), 2, org.xml3d.FilterTypes);
		   
		   if(this._filterMag.setOwnerNode)
		   {
		   	  this._filterMag.setOwnerNode("filterMag", this);
		   }
		}
		else
		{
		   this._filterMag = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._filterMag)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "filterMag", oldValue, this._filterMag));
		}
	});
  
	node.__defineGetter__("filterMag", function (value) 
	{
        return this._filterMag;
    });
	node.__defineSetter__("filterMip", function (value) 
	{
		var oldValue = this._filterMip;
		if (typeof value == 'string')
		{
		   this._filterMip = org.xml3d.initEnum(node.getAttribute("filterMip"), 1, org.xml3d.FilterTypes);
		   
		   if(this._filterMip.setOwnerNode)
		   {
		   	  this._filterMip.setOwnerNode("filterMip", this);
		   }
		}
		else
		{
		   this._filterMip = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._filterMip)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "filterMip", oldValue, this._filterMip));
		}
	});
  
	node.__defineGetter__("filterMip", function (value) 
	{
        return this._filterMip;
    });
	node.__defineSetter__("wrapS", function (value) 
	{
		var oldValue = this._wrapS;
		if (typeof value == 'string')
		{
		   this._wrapS = org.xml3d.initEnum(node.getAttribute("wrapS"), 0, org.xml3d.WrapTypes);
		   
		   if(this._wrapS.setOwnerNode)
		   {
		   	  this._wrapS.setOwnerNode("wrapS", this);
		   }
		}
		else
		{
		   this._wrapS = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._wrapS)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "wrapS", oldValue, this._wrapS));
		}
	});
  
	node.__defineGetter__("wrapS", function (value) 
	{
        return this._wrapS;
    });
	node.__defineSetter__("wrapT", function (value) 
	{
		var oldValue = this._wrapT;
		if (typeof value == 'string')
		{
		   this._wrapT = org.xml3d.initEnum(node.getAttribute("wrapT"), 0, org.xml3d.WrapTypes);
		   
		   if(this._wrapT.setOwnerNode)
		   {
		   	  this._wrapT.setOwnerNode("wrapT", this);
		   }
		}
		else
		{
		   this._wrapT = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._wrapT)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "wrapT", oldValue, this._wrapT));
		}
	});
  
	node.__defineGetter__("wrapT", function (value) 
	{
        return this._wrapT;
    });
	node.__defineSetter__("wrapU", function (value) 
	{
		var oldValue = this._wrapU;
		if (typeof value == 'string')
		{
		   this._wrapU = org.xml3d.initEnum(node.getAttribute("wrapU"), 0, org.xml3d.WrapTypes);
		   
		   if(this._wrapU.setOwnerNode)
		   {
		   	  this._wrapU.setOwnerNode("wrapU", this);
		   }
		}
		else
		{
		   this._wrapU = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._wrapU)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "wrapU", oldValue, this._wrapU));
		}
	});
  
	node.__defineGetter__("wrapU", function (value) 
	{
        return this._wrapU;
    });
	node.__defineSetter__("borderColor", function (value) 
	{
		var oldValue = this._borderColor;
		if (typeof value == 'string')
		{
		   this._borderColor = org.xml3d.initString(node.getAttribute("borderColor"), "");
		   
		   if(this._borderColor.setOwnerNode)
		   {
		   	  this._borderColor.setOwnerNode("borderColor", this);
		   }
		}
		else
		{
		   this._borderColor = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._borderColor)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "borderColor", oldValue, this._borderColor));
		}
	});
  
	node.__defineGetter__("borderColor", function (value) 
	{
        return this._borderColor;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "type")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.type = 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "filterMin")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.filterMin = 2;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "filterMag")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.filterMag = 2;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "filterMip")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.filterMip = 1;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "wrapS")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.wrapS = 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "wrapT")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.wrapT = 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "wrapU")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.wrapU = 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "borderColor")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.borderColor = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._type = org.xml3d.initEnum(node.getAttribute("type"), 0, org.xml3d.TextureTypes);
	if(node._type.setOwnerNode)
	{
		node._type.setOwnerNode("type", this);
	}
	node._filterMin = org.xml3d.initEnum(node.getAttribute("filterMin"), 2, org.xml3d.FilterTypes);
	if(node._filterMin.setOwnerNode)
	{
		node._filterMin.setOwnerNode("filterMin", this);
	}
	node._filterMag = org.xml3d.initEnum(node.getAttribute("filterMag"), 2, org.xml3d.FilterTypes);
	if(node._filterMag.setOwnerNode)
	{
		node._filterMag.setOwnerNode("filterMag", this);
	}
	node._filterMip = org.xml3d.initEnum(node.getAttribute("filterMip"), 1, org.xml3d.FilterTypes);
	if(node._filterMip.setOwnerNode)
	{
		node._filterMip.setOwnerNode("filterMip", this);
	}
	node._wrapS = org.xml3d.initEnum(node.getAttribute("wrapS"), 0, org.xml3d.WrapTypes);
	if(node._wrapS.setOwnerNode)
	{
		node._wrapS.setOwnerNode("wrapS", this);
	}
	node._wrapT = org.xml3d.initEnum(node.getAttribute("wrapT"), 0, org.xml3d.WrapTypes);
	if(node._wrapT.setOwnerNode)
	{
		node._wrapT.setOwnerNode("wrapT", this);
	}
	node._wrapU = org.xml3d.initEnum(node.getAttribute("wrapU"), 0, org.xml3d.WrapTypes);
	if(node._wrapU.setOwnerNode)
	{
		node._wrapU.setOwnerNode("wrapU", this);
	}
	node._borderColor = org.xml3d.initString(node.getAttribute("borderColor"), "");
	if(node._borderColor.setOwnerNode)
	{
		node._borderColor.setOwnerNode("borderColor", this);
	}

	node.imageData = null;




	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "name") 
		{
			this.name = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "type") 
		{
			this.type = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "filterMin") 
		{
			this.filterMin = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "filterMag") 
		{
			this.filterMag = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "filterMip") 
		{
			this.filterMip = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "wrapS") 
		{
			this.wrapS = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "wrapT") 
		{
			this.wrapT = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "wrapU") 
		{
			this.wrapU = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "borderColor") 
		{
			this.borderColor = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.XML3DImageDataProviderType()
 * 
 * @augments org.xml3d.classInfo.XML3DReferenceableType
 * @constructor
 * @see org.xml3d.classInfo.XML3DReferenceableType
 */
org.xml3d.classInfo.XML3DImageDataProviderType = function(node, context) 
{
	org.xml3d.classInfo.XML3DReferenceableType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes

	node.resetAttribute = function(attrName)
	{
		return org.xml3d.event.UNHANDLED;
	};






	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.img()
 * 
 * @augments org.xml3d.classInfo.XML3DImageDataProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DImageDataProviderType
 */
org.xml3d.classInfo.img = function(node, context) 
{
	org.xml3d.classInfo.XML3DImageDataProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("src", function (value) 
	{
		var oldValue = this._src;
		if (typeof value == 'string')
		{
		   this._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
		   
		   if(this._src.setOwnerNode)
		   {
		   	  this._src.setOwnerNode("src", this);
		   }
		}
		else
		{
		   this._src = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._src)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "src", oldValue, this._src));
		}
	});
  
	node.__defineGetter__("src", function (value) 
	{
        return this._src;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "src")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.src = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
	if(node._src.setOwnerNode)
	{
		node._src.setOwnerNode("src", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "src") 
		{
			this.src = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.video()
 * 
 * @augments org.xml3d.classInfo.XML3DImageDataProviderType
 * @constructor
 * @see org.xml3d.classInfo.XML3DImageDataProviderType
 */
org.xml3d.classInfo.video = function(node, context) 
{
	org.xml3d.classInfo.XML3DImageDataProviderType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("src", function (value) 
	{
		var oldValue = this._src;
		if (typeof value == 'string')
		{
		   this._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
		   
		   if(this._src.setOwnerNode)
		   {
		   	  this._src.setOwnerNode("src", this);
		   }
		}
		else
		{
		   this._src = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._src)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "src", oldValue, this._src));
		}
	});
  
	node.__defineGetter__("src", function (value) 
	{
        return this._src;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "src")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.src = "";
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._src = org.xml3d.initAnyURI(node.getAttribute("src"), "");
	if(node._src.setOwnerNode)
	{
		node._src.setOwnerNode("src", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "src") 
		{
			this.src = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

	
};
/**
 * Object org.xml3d.classInfo.view()
 * 
 * @augments org.xml3d.classInfo.XML3DGraphType
 * @constructor
 * @see org.xml3d.classInfo.XML3DGraphType
 */
org.xml3d.classInfo.view = function(node, context) 
{
	org.xml3d.classInfo.XML3DGraphType(node, context);
	//org.xml3d.classInfo.Xml3dNode(node, context);
// eAllAttributes
	node.__defineSetter__("position", function (value) 
	{
		var oldValue = this._position;
		if (typeof value == 'string')
		{
		   this._position = org.xml3d.initXML3DVec3(node.getAttribute("position"), 0, 0, 0);
		   
		   if(this._position.setOwnerNode)
		   {
		   	  this._position.setOwnerNode("position", this);
		   }
		}
		else
		{
		   this._position = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._position)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "position", oldValue, this._position));
		}
	});
  
	node.__defineGetter__("position", function (value) 
	{
        return this._position;
    });
	node.__defineSetter__("orientation", function (value) 
	{
		var oldValue = this._orientation;
		if (typeof value == 'string')
		{
		   this._orientation = org.xml3d.initXML3DRotation(node.getAttribute("orientation"), 0, 0, 1, 0);
		   
		   if(this._orientation.setOwnerNode)
		   {
		   	  this._orientation.setOwnerNode("orientation", this);
		   }
		}
		else
		{
		   this._orientation = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._orientation)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "orientation", oldValue, this._orientation));
		}
	});
  
	node.__defineGetter__("orientation", function (value) 
	{
        return this._orientation;
    });
	node.__defineSetter__("fieldOfView", function (value) 
	{
		var oldValue = this._fieldOfView;
		if (typeof value == 'string')
		{
		   this._fieldOfView = org.xml3d.initFloat(node.getAttribute("fieldOfView"), 0.785398);
		   
		   if(this._fieldOfView.setOwnerNode)
		   {
		   	  this._fieldOfView.setOwnerNode("fieldOfView", this);
		   }
		}
		else
		{
		   this._fieldOfView = value;
    	}
    	
		if (this.notificationRequired() && oldValue != this._fieldOfView)
		{
			this.notify(new org.xml3d.Notification(this, MutationEvent.MODIFICATION, "fieldOfView", oldValue, this._fieldOfView));
		}
	});
  
	node.__defineGetter__("fieldOfView", function (value) 
	{
        return this._fieldOfView;
    });

	node.resetAttribute = function(attrName)
	{
		if(attrName == "position")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.position = 0, 0, 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "orientation")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.orientation = 0, 0, 1, 0;
			return org.xml3d.event.HANDLED;
		}
		if(attrName == "fieldOfView")
		{
			// An event is triggered through the corresponding setter. Therefore,
			// no further notification is required.
			this.fieldOfView = 0.785398;
			return org.xml3d.event.HANDLED;
		}
		return org.xml3d.event.UNHANDLED;
	};

	node._position = org.xml3d.initXML3DVec3(node.getAttribute("position"), 0, 0, 0);
	if(node._position.setOwnerNode)
	{
		node._position.setOwnerNode("position", this);
	}
	node._orientation = org.xml3d.initXML3DRotation(node.getAttribute("orientation"), 0, 0, 1, 0);
	if(node._orientation.setOwnerNode)
	{
		node._orientation.setOwnerNode("orientation", this);
	}
	node._fieldOfView = org.xml3d.initFloat(node.getAttribute("fieldOfView"), 0.785398);
	if(node._fieldOfView.setOwnerNode)
	{
		node._fieldOfView.setOwnerNode("fieldOfView", this);
	}





	// Node::setField
	node.setField = function(event)	
	{
		var attrName = event.attrName;
		if (attrName == "id") 
		{
			this.id = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "class") 
		{
			this.class = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "style") 
		{
			this.style = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onclick") 
		{
			this.onclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "ondblclick") 
		{
			this.ondblclick = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousedown") 
		{
			this.onmousedown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseup") 
		{
			this.onmouseup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseover") 
		{
			this.onmouseover = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmousemove") 
		{
			this.onmousemove = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onmouseout") 
		{
			this.onmouseout = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeypress") 
		{
			this.onkeypress = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeydown") 
		{
			this.onkeydown = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "onkeyup") 
		{
			this.onkeyup = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "visible") 
		{
			this.visible = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "position") 
		{
			this.position = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "orientation") 
		{
			this.orientation = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		if (attrName == "fieldOfView") 
		{
			this.fieldOfView = event.newValue;
			return org.xml3d.event.HANDLED;
		}
		
		return org.xml3d.event.UNHANDLED;
	};

		node.getWorldMatrix = org.xml3d.methods.XML3DGraphTypeGetWorldMatrix;
		node.setDirection = org.xml3d.methods.viewSetDirection;
		node.setUpVector = org.xml3d.methods.viewSetUpVector;
		node.lookAt = org.xml3d.methods.viewLookAt;
		node.getDirection = org.xml3d.methods.viewGetDirection;
		node.getUpVector = org.xml3d.methods.viewGetUpVector;
		node.getViewMatrix = org.xml3d.methods.viewGetViewMatrix;
	
};
org.xml3d.methods.xml3dCreateXML3DVec3 = function() {
	return new XML3DVec3();
};

org.xml3d.methods.xml3dCreateXML3DMatrix = function () {
	return new XML3DMatrix();
};

org.xml3d.methods.xml3dCreateXML3DRotation = function() {
	return new XML3DRotation();
};

org.xml3d.methods.viewGetDirection = function() {
	return this.orientation.rotateVec3(new XML3DVec3(0,0,-1));
};

org.xml3d.methods.viewSetPosition = function(pos) {
	this.position = pos;
};

org.xml3d.methods.viewSetDirection = function(quat) {
	this.orientation = quat;
};

org.xml3d.methods.viewGetUpVector = function() {
	return this.orientation.rotateVec3(new XML3DVec3(0, 1, 0));
};

org.xml3d.methods.viewLookAt = function(vec) {
	// TODO: write lookat function
};
